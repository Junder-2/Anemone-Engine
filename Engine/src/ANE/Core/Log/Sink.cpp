/*     SPDX-License-Identifier: BSD-3-Clause     */

//        Copyright The Authors 2021.
//    Distributed under the 3-Clause BSD License.
//    (See accompanying file LICENSE or copy at
//   https://opensource.org/licenses/BSD-3-Clause)
#include "anepch.h"

#include "sink.h"
// for time formatting
// Disable warning generated by yaml-cpp

#include "ANE/Core/Config/Config.h"
#include "LogSinkBase.h"
#include "../toml/include/toml.hpp"
#include <array>
#include <filesystem>
#include <fstream>
#include <sstream> // for log record formatting

// spdlog puts template definitions in separate files from the .h files. We ned
// to declare the template explicit instantiation present in the implementation
// files to avoid compiler warnings.
extern template class spdlog::sinks::base_sink<std::mutex>;

namespace Engine
{
    const char* const Engine::ImGuiLogSink::LOGGER_NAME = "main";

    const ImVec4 ImGuiLogSink::COLOR_WARN{0.9F, 0.7F, 0.0F, 1.0F};
    const ImVec4 ImGuiLogSink::COLOR_ERROR{1.0F, 0.0F, 0.0F, 1.0F};

    void ImGuiLogSink::Clear()
    {
        std::unique_lock<std::shared_timed_mutex> lock(records_mutex_);
        records_.clear();
    }

    void ImGuiLogSink::ShowLogLevelsPopup()
    {
        ImGui::MenuItem("Logging Levels", nullptr, false, false);

        std::vector<int> levels;
        for (auto& a_logger : Registry::Loggers())
        {
            levels.push_back(a_logger.second.GetLevel());
            auto format =
                std::string("%u (")
                .append(spdlog::level::to_string_view(a_logger.second.GetLevel())
                    .data())
                .append(")");
            if (ImGui::SliderInt(a_logger.second.Name().c_str(), &levels.back(), 0, 6,
                                 format.c_str()))
            {
                a_logger.second.SetLevel(spdlog::level::level_enum(levels.back()));
            }
        }
    }

    void ImGuiLogSink::ShowLogFormatPopup()
    {
        ImGui::MenuItem("Logging Format", nullptr, false, false);
        ImGui::Checkbox("Time", &show_time_);
        ImGui::SameLine();
        ImGui::Checkbox("Thread", &show_thread_);
        ImGui::SameLine();
        ImGui::Checkbox("Level", &show_level_);
        ImGui::SameLine();
        ImGui::Checkbox("Logger", &show_logger_);
    }

    void ImGuiLogSink::Draw(const char* title, bool* open)
    {
        ImGui::SetNextWindowSize(ImVec2(500, 400), ImGuiCond_FirstUseEver);

        // This is the case when the log viewer is supposed to open in its own ImGui
        // window (not docked).
        if (open != nullptr)
        {
            ImGui::Begin(title, open);
        }

        /*
        if (ImGui::Button("Log something...")) {
          BXLOG_MISC(trace, "TRACE");
          BXLOG_MISC(debug, "DEBUG");
          BXLOG_MISC(info, "INFO");
          BXLOG_MISC(warn, "WARN");
          BXLOG_MISC(error, "ERROR");
          BXLOG_MISC(critical, "CRITICAL");
        }
        */

        // -------------------------------------------------------------------------
        // Toolbar
        // -------------------------------------------------------------------------

        {
            // Make all buttons transparent in the toolbar
            auto button_color = ImGui::GetStyleColorVec4(ImGuiCol_Button);
            button_color.w = 0.0F;
            ImGui::PushStyleColor(ImGuiCol_Button, button_color);

            if (ImGui::Button(" Levels"))
            {
                ImGui::OpenPopup("LogLevelsPopup");
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Change the logging levels");
            }
            if (ImGui::BeginPopup("LogLevelsPopup"))
            {
                ShowLogLevelsPopup();
                ImGui::EndPopup();
            }

            ImGui::SameLine();
            if (ImGui::Button(" Format"))
            {
                ImGui::OpenPopup("LogFormatPopup");
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Chose what information to show");
            }
            if (ImGui::BeginPopup("LogFormatPopup"))
            {
                ShowLogFormatPopup();
                ImGui::EndPopup();
            }

            ImGui::SameLine();
            if (ImGui::Button(" Clear"))
            {
                Clear();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Discard all messages");
            }

            ImGui::SameLine();
            bool need_pop_style_var = false;
            if (wrap_)
            {
                // Highlight the button
                ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 2.0F);
                ImGui::PushStyleColor(
                    ImGuiCol_Border, ImGui::GetStyleColorVec4(ImGuiCol_TextSelectedBg));
                need_pop_style_var = true;
            }
            if (ImGui::Button("Wrap"))
            {
                ToggleWrap();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Toggle soft wraps");
            }
            if (need_pop_style_var)
            {
                ImGui::PopStyleColor();
                ImGui::PopStyleVar();
            }

            ImGui::SameLine();
            need_pop_style_var = false;
            if (scroll_lock_)
            {
                // Highlight the button
                ImGui::PushStyleVar(ImGuiStyleVar_FrameBorderSize, 2.0F);
                ImGui::PushStyleColor(
                    ImGuiCol_Border, ImGui::GetStyleColorVec4(ImGuiCol_TextSelectedBg));
                need_pop_style_var = true;
            }
            if (ImGui::Button("Toggle Scroll lock"))
            {
                ToggleScrollLock();
            }
            if (ImGui::IsItemHovered())
            {
                ImGui::SetTooltip("Toggle automatic scrolling to the bottom");
            }
            if (need_pop_style_var)
            {
                ImGui::PopStyleColor();
                ImGui::PopStyleVar();
            }

            ImGui::SameLine();
            display_filter_.Draw(" Filter", -100.0F);
        }
        // Restore the button color
        ImGui::PopStyleColor();

        // -------------------------------------------------------------------------
        // Log records
        // -------------------------------------------------------------------------

        ImGui::Separator();
        ImGui::BeginChild(
            "scrolling", ImVec2(0, 0), false, ImGuiWindowFlags_HorizontalScrollbar);

        {
            ImGui::PushStyleVar(ImGuiStyleVar_ItemSpacing, ImVec2(0, 1));

            std::shared_lock<std::shared_timed_mutex> lock(records_mutex_);
            for (auto const& record : records_)
            {
                if (!display_filter_.IsActive() ||
                    display_filter_.PassFilter(record.properties_.c_str(),
                                               record.properties_.c_str() + record.properties_.size()) ||
                    display_filter_.PassFilter(record.source_.c_str(),
                                               record.source_.c_str() + record.source_.size()) ||
                    display_filter_.PassFilter(record.message_.c_str(),
                                               record.message_.c_str() + record.message_.size()))
                {
                    ImGui::BeginGroup();

                    if (record.color_range_start_ > 0)
                    {
                        auto props_len = record.properties_.size();

                        std::string part =
                            record.properties_.substr(0, record.color_range_start_);
                        ImGui::TextUnformatted(part.c_str());
                        ImGui::SameLine();

                        part = record.properties_.substr(record.color_range_start_,
                                                         record.color_range_end_ - record.color_range_start_);
                        ImGui::TextColored(record.color_, "%s", part.c_str());

                        part = record.properties_.substr(
                            record.color_range_end_, props_len - record.color_range_end_);
                        ImGui::SameLine();
                        ImGui::TextUnformatted(part.c_str());
                    }
                    else
                    {
                        if (record.color_range_end_ == 1)
                        {
                            ImGui::TextColored(record.color_, "%s", record.properties_.c_str());
                        }
                        else
                        {
                            ImGui::TextUnformatted(record.properties_.c_str());
                        }
                    }

                    if (record.color_range_end_ == 1)
                    {
                        ImGui::SameLine();
                        if (wrap_)
                        {
                            ImGui::PushTextWrapPos(0.0F);
                        }
                        ImGui::TextColored(record.color_, "%s", record.message_.c_str());
                        if (wrap_)
                        {
                            ImGui::PopTextWrapPos();
                        }
                    }
                    else
                    {
                        ImGui::SameLine();
                        if (wrap_)
                        {
                            ImGui::PushTextWrapPos(0.0F);
                        }
                        ImGui::TextUnformatted(record.message_.c_str());
                        if (wrap_)
                        {
                            ImGui::PopTextWrapPos();
                        }
                    }
                    ImGui::EndGroup();
                    #ifndef NDEBUG
                    // We only show the tooltip with the source location if in debug build.
                    // The source location information is not produced in the logs in
                    // non-debug builds.
                    if (ImGui::IsItemHovered())
                    {
                        ImGui::SetTooltip("%s", record.source_.c_str());
                    }
                    #endif // NDEBUG
                }
            }
        }
        ImGui::PopStyleVar();

        if (!scroll_lock_ && scroll_to_bottom_)
        {
            ImGui::SetScrollHereY(1.0F);
        }
        scroll_to_bottom_ = false;
        ImGui::EndChild();

        // The case of the log viewer in its own ImGui window (not docked)
        if (open != nullptr)
        {
            ImGui::End();
        }
    }

    void ImGuiLogSink::sink_it_(const spdlog::details::log_msg& msg)
    {
        auto ostr = std::ostringstream();
        std::size_t color_range_start = 0;
        std::size_t color_range_end = 0;
        ImVec4 const* color = nullptr;
        auto emphasis = false;

        if (show_time_)
        {

           // ostr << "[" << toml::date{local_time_format(msg.time)}"%D %T %Z", msg.time) << "] "; // todo: fix a date formatter
        }
        if (show_thread_)
        {
            ostr << "[" << msg.thread_id << "] ";
        }
        if (show_level_)
        {
            color_range_start = static_cast<std::size_t>(ostr.tellp());
            ostr << "[" << spdlog::level::to_short_c_str(msg.level) << "] ";
            color_range_end = static_cast<std::size_t>(ostr.tellp());
        }
        if (show_logger_)
        {
            ostr.put('[')
                .write(msg.logger_name.data(), msg.logger_name.size())
                .write("] ", 2);
        }
        auto properties = ostr.str();

        // Strip the filename:line from the message and put it in a separate string
        auto msg_str = std::string(msg.payload.data(), msg.payload.size());
        auto skip_to = msg_str.begin();
        if (*skip_to == '[')
        {
            // skip spaces
            while (skip_to != msg_str.end() && *skip_to != ']')
            {
                ++skip_to;
            }
            if (skip_to == msg_str.end())
            {
                skip_to = msg_str.begin();
            }
            else
            {
                auto saved_skip_to = skip_to + 1;
                while (skip_to != msg_str.begin())
                {
                    --skip_to;
                    if (*skip_to == ':' || (std::isdigit(*skip_to) == 0))
                    {
                        break;
                    }
                }
                if (*skip_to == ':')
                {
                    skip_to = ++saved_skip_to; // Add one space
                }
            }
        }
        // Source location will be found only in non-debug builds.
        #ifndef NDEBUG
        // Ignore the '[' and ']'
        auto check = (skip_to - msg_str.begin() - 3) >= 0;
        auto source = msg_str.substr(
            1, static_cast<std::size_t>(skip_to - msg_str.begin() - 3));
        #else
  auto source = std::string();
        #endif // NDEBUG
        // Select display color and colored text range based on level
        switch (msg.level)
        {
            case spdlog::level::trace:
                color = &ImGui::GetStyleColorVec4(ImGuiCol_TextDisabled);
            // the entire message
                color_range_start = 0;
                color_range_end = 1;
                break;

            case spdlog::level::debug:
                color = &ImGui::GetStyleColorVec4(ImGuiCol_Text);
            // The level part if show, otherwise no coloring
                break;

            case spdlog::level::info:
                color = &ImGui::GetStyleColorVec4(ImGuiCol_NavHighlight);
            // The level part if show, otherwise no coloring
                break;

            case spdlog::level::warn:
                color = &COLOR_WARN;
            // the entire message
                color_range_start = 0;
                color_range_end = 1;
                break;

            case spdlog::level::err:
                color = &COLOR_ERROR;
            // the entire message
                color_range_start = 0;
                color_range_end = 1;
                break;

            case spdlog::level::critical:
                color = &COLOR_ERROR;
                emphasis = true;
            // the entire message
                color_range_start = 0;
                color_range_end = 1;
                break;

            default:
                // Nothing
                ;
        }

        auto record =
            LogRecord{
                properties, source, msg_str.substr(skip_to - msg_str.begin()),
                color_range_start, color_range_end, *color, emphasis
            };
        {
            std::unique_lock<std::shared_timed_mutex> lock(records_mutex_);
            records_.push_back(std::move(record));
        }
        scroll_to_bottom_ = true;
    }

    void ImGuiLogSink::flush_()
    {
        // Your code here
    }

    void ImGuiLogSink::LoadSettings()
    {
        auto log_settings =
            GetPathFor(Location::F_LOG_SETTINGS);
        if (!std::filesystem::exists(log_settings))
        {
            return;
        }
        try
        {
            auto config = toml::parse_file(log_settings.string());

            toml::array* loggers;
            if (config["loggers"] &&
                (loggers = config["loggers"].as_array()) != nullptr)
            {
                for (auto& item : *loggers)
                {
                    auto settings = *item.as_table();
                    auto name = settings["name"].value<std::string>().value();
                    auto level = settings["level"].value<int>().value();
                    auto& logger = Registry::GetLogger(name);
                    logger.set_level(static_cast<spdlog::level::level_enum>(level));
                }
            }

            auto format = config["format"];
            if (format)
            {
                if (format["show-time"])
                {
                    show_time_ = format["show-time"].value<bool>().value();
                }
                if (format["show-thread"])
                {
                    show_thread_ = format["show-thread"].value<bool>().value();
                }
                if (format["show-logger"])
                {
                    show_logger_ = format["show-logger"].value<bool>().value();
                }
                if (format["show-level"])
                {
                    show_level_ = format["show-level"].value<bool>().value();
                }
            }

            if (format["scroll-lock"])
            {
                scroll_lock_ = format["scroll-lock"].value<bool>().value();
            }
            if (format["soft-wrap"])
            {
                wrap_ = format["soft-wrap"].value<bool>().value();
            }
        }
        catch (std::exception const& ex)
        {
           throw;
        }
    }

    void ImGuiLogSink::SaveSettings()
    {
        toml::array loggers;

        for (auto& log : Registry::Loggers())
        {
            loggers.push_back(toml::table{
                {"name", log.second.Name()},
                {
                    "level",
                    static_cast<
                        typename std::underlying_type<spdlog::level::level_enum>::type>(
                        log.second.GetLevel())
                }
            });
        }

        auto root = toml::table{
            {"loggers", loggers},
            {
                "format",
                toml::table{
                    {"show-time", show_time_},
                    {"show-thread", show_thread_},
                    {"show-level", show_level_},
                    {"show-logger", show_logger_},
                }
            },
            {"scroll-lock", scroll_lock_},
            {"soft-wrap", wrap_},
        };

        auto settings_path =
            GetPathFor(Location::F_LOG_SETTINGS);
        auto ofs = std::ofstream();
        ofs.open(settings_path.string());
        ofs << "# Logging configuration (toml 0.5.1)" << std::endl;
        ofs << root << std::endl;
        ofs.close();
    }
} // namespace asap::ui
